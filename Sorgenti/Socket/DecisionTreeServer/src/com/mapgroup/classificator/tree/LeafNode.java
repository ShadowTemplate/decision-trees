package com.mapgroup.classificator.tree;

import com.mapgroup.classificator.data.Data;
import com.mapgroup.classificator.data.DiscreteAttribute;

/**
 * This class models the leaf node of the decision tree
 */

public class LeafNode extends Node {

    /**
     * Class attribute value expressed in the leaf node
     */
    private final String predictedClassValue;

    /**
     * Instantiates an object by invoking the superclass constructor and sets <code>predictedClassValue</code>
     *
     * @param trainingSet current training set
     * @param beginExampleIndex first extreme of the training subset
     * @param endExampleIndex last extreme of the training subset
     */

    LeafNode(Data trainingSet, int beginExampleIndex, int endExampleIndex) {
        super(trainingSet, beginExampleIndex, endExampleIndex);
        predictedClassValue = determineMostFrequentClass(trainingSet);
    }

    /**
     * Return the value of <code>predictedClassValue</code>
     *
     * @return <code>predictedClassValue</code>
     */

    public String getPredictedClassValue() {

        return predictedClassValue;
    }

    /**
     * Determines the most frequently class attribute in the training subset
     *
     * @param trainingSet current training set
     * @return the most frequently class attribute in the training subset
     */

    private String determineMostFrequentClass(Data trainingSet) {
        DiscreteAttribute classAttr = trainingSet.getClassAttribute();
        String maxValue = null;
        int currMax = 0;
        String currString;
        int currFrequency;

        for (int i = 0; i < classAttr.getNumOfDistinctValues(); i++) {
            currString = classAttr.getValue(i);
            currFrequency = classValueAbsoluteFrequency.get(currString);

            if (currMax < currFrequency) {
                currMax = currFrequency;
                maxValue = currString;
            }
        }

        return maxValue;
    }

    /**
     * Returns the number of the split node generated by leaf node.
     *
     * @return <code>0</code> (leaf node hasn't children)
     */

    public int getNumberOfChildren() {
        return 0;
    }

    /**
     * Return a <code>String</code> which represents the value of <code>predictedClassValue</code>
     * and the method of the superclass
     *
     * @return the value of <code>predictedClassValue</code> concatenates node
     */

    public String toString() {
        return ("[Leaf] Class Value = " + predictedClassValue + " " + super.toString());
    }
}
